---
title: 【算法】零散的算法记录
tags: algorithm
---

### 卡特兰数
一些LeetCode题目和经典问题与**_卡特兰数_** $G(n)$ 有关：

* [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/description/)：$n$ 对合法的括号数量
* $n$ 个数可能的入栈出栈顺序的数量
* **_Dyck路径_**：从 $(0, 0)$ 走到 $(n, n)$ 走 $2n$ 步，每次可以向左或向右一步，且始终不越过对角线($y\ge x$)的路径数量

这些题目的结果都是卡特兰数$G(n)$，原因是它们的输入都是 $n$，且具有相同的“前缀约束”：比如合法的括号字符串的前缀满足“$左括号数量\ge 右括号数量$”，入栈出栈顺序满足“$入栈数量\ge 出栈数量$”，Dyck路径满足“$x\ge y$”。且**最终到不等号两边都等于 $n$**。还有一个卡特兰数的例子是，A和B的票数最终都是 $n$，且投票过程中 $A的票数 \ge B的票数$，求所有可能的投票过程数量。

这种性质使得我们可以把它转化为递归的形式：如果**不等号第一次取等的前缀长度**是 $i$ ，那么就得到了两个子问题：从0到 $i$ 的结果数量是 $G(i-1)$，从 $i$ 到 $n$ 的数量是 $G(n-i)$，于是枚举不同的 $i$ 可以得到递归的式子：

$$
G(n) = \sum_{i=1}^n G(i-1)G(n-i)
$$

这样就得到了卡特兰数的递归公式，可以求出：

$$
G(n) = \frac{1}{n+1}C_{2n}^n = \frac{(2n)!}{(n+1)!n!}
$$

还有一道hot100题目：[96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees)也和卡特兰数有关。但是它的“前缀约束”就没有前面的例子直观：从中序遍历考虑，DFS中序遍历会访问每个顶点两次，出发一次，返回一次，DFS过程中“$出发次数\ge 返回次数$”。由于DFS本质也是栈的顺序，所以和前面栈的例子完全等价，但二叉树的例子有非常直接的递归结构能直接得到卡特兰数公式。


### 蓄水池抽样

流式数据如何随机的采样 $k$ 个样本？蓄水池抽样给出了一个非常简单的算法，每次抽样复杂度都是$O(1)$：

```python
class Sampler:
    def __init__(self, k):
        self.k = k
        self.n = 0
        self.reservoir = []
    
    def update(self, x):
        """
        每产生一个流式样本x就调用一次, O(1)
        """
        self.n += 1;
        if len(self.reservoir) < self.k:
            self.reservoir.append(x)
            return

        i = random.randint(0, self.n)
        if i < k:  # 以k/n的概率决定是否替换
            self.reservoir[i] = x
    
    def sample(self):
        """
        返回采样的k个样本, O(1)
        """
        return self.reservoir
```

可以证明 $n\ge k$ 时采样到到第 $j\ge k$ 个样本的概率是 $\frac{k}{n}$。因为第 $j$ 个样本被采样意味着它加入蓄水池（概率是 $\frac{k}{j}$），且后续一直不被替换出去（概率是 $\frac{j}{j+1}\frac{j+1}{j+2}\cdots\frac{n-1}{n}=\frac{j}{n}$），二者相乘就得到了概率 $\frac{k}{n}$。


### Alias Method

<!-- 2025年9月 -->
推荐系统需要根据item热度进行采样，但是item非常多，要实现高效的采样，需要在O(1)的复杂度下根据给定的概率数组进行采样。恰好有这样一种算法叫Alias Method。

<div align=center>
<img src="../../../assets/images/posts/2025-08-17/alias_method.png" width="60%" />
<p style="font-style: italic; color: gray; margin-top: 0.5em;">
</p>
</div>

如上图所示，alias method简单来说就是把概率比较高的补到概率比较低的桶去，保证重新分配之后每个桶的概率加起来都是 $\frac1n$。之后乘以 $n$，每个桶的概率值都是1。每个桶内又有一个阈值，低于这个阈值的就是这个桶本身的数，高于这个阈值的就是其它地方分配过来的（叫alias）。采样的时候，随机选一个桶，然后产生一个随机数，看随机数是否低于阈值，低于返回原始值，高于就返回alias。

```python
import numpy as np

class AliasSampler:
    def __init__(self, probs):
        self.n = len(probs)
        self.probs = np.array(probs) / sum(probs)
        self.alias = np.zeros(self.n, dtype=np.int32)
        self.accept = np.zeros(self.n)
        self._build_table()

    def _build_table(self):
        """
        以O(n)复杂度构建alias和accept表
        """
        small = []
        large = []
        scaled_probs = self.probs * self.n
        for i, p in enumerate(scaled_probs):
            if p < 1.0:
                small.append(i)
            else:
                large.append(i)

        while small and large:
            s = small.pop()
            l = large.pop()
            self.accept[s] = scaled_probs[s]
            self.alias[s] = l
            scaled_probs[l] = (scaled_probs[l] + scaled_probs[s]) - 1.0
            if scaled_probs[l] < 1.0:
                small.append(l)
            else:
                large.append(l)

        while large:
            l = large.pop()
            self.accept[l] = 1.0
        while small:
            s = small.pop()
            self.accept[s] = 1.0

    def sample(self, size=1):
        """
        采样size个树，O(k)
        """
        indices = np.random.randint(0, self.n, size)
        r = np.random.rand(size)
        mask = r < self.accept[indices]
        return np.where(mask, indices, self.alias[indices])
```

<!-- ### 字典序

- [31. 下一个排列](https://leetcode.cn/problems/next-permutation/description/)
- [402. 移掉 K 位数字](https://leetcode.cn/problems/remove-k-digits/description/)

字典序相关的问题一般涉及一个性质：**元素从小到大排序得到的字符串是最小的，从大到小则是最大的**。
 -->
