---
title: 二分图匹配
tags: algorithm
---

用$G$表示二分图，二分图的两个顶点集合用$X$和$Y$表示，记$n=\|X\|$，$m=\|Y\|$。

## 图的匹配

先介绍一些概念：
匹配：图$G$的匹配是$G$的边子集，且该子集中任意两条边没有公共顶点
$G$的所有匹配中边数最多的匹配称为最大匹配，如果该最大匹配饱和了$G$中所有顶点，则称为完美匹配
。最大匹配可能不止一个，完美匹配不一定存在。
饱和了$G$中所有顶点，指$G$中所有顶点都是该匹配的饱和点。

设$M$是一个匹配，如果一个顶点是$M$中一条边的顶点，则称该顶点为$M$饱和点，否则称为$M$非饱和点。$G$中一条由$M$中的边与非$M$中的边交错形成的路称为$M$交错路。交错路只有起点、终点可能是$M$非饱和点，中间的点都是$M$饱和点
$M$交错路有三种情况：

1. 起点、终点其中之一是$M$饱和点，则该交错路中非M中的边数等于M中的边数
2. 起点、终点都是$M$饱和点，则该交错路中非M中的边比M中的边少一条
3. 起点、终点都是$M$非饱和点，则该交错路中非M中的边比M中的边多一条
    此时$M$交错路称为$M$增广路。因为这条路中，非M中的边构成的匹配比M大，因此非M的边是一个更大的匹配，所以叫增广路。更形式化的说，可以通过$M\Delta E(P)=M\cup E(P)-M\cap E(P)$得到一个新的匹配，且匹配数增加了1。这里$E(P)$是增广路$P$的边集。

### Berge定理

对称差引理：设$M_1$和$M_2$是$G$的两个匹配，如果$H=M_1\Delta M_2≠\emptyset$，则$H$由多个路径或偶环组成，且路径或偶环的边交替属于$M_1$和$M_2$（这个导致环一定是偶数条边，所以是偶环，属于$M_1$和$M_2$的边各占一半）
    - 因为$M_1$和$M_2$是匹配，求对称差之后至多有两条边邻接，也就是说对一个顶点最多与两条边邻接（度数至多为2），并且一个属于$M_1$，一个属于$M_2$。所以$H$一定由路径或环组成，因为只有路径和环的顶点度数不超过2。
    - 这里应该好理解，核心原因是匹配内部的边总是不相交的。

$G$的匹配$M$是最大匹配的充要条件是$G$不包含增广路
必要性：反证法，假设存在增广路，则可以增大匹配，矛盾，所以最大匹配不存在增广路。
充分性：反证法，如果$M$不是最大匹配，则存在更大的匹配$M'$，考虑二者的对称差$M\Delta M'$，由对称差引理，它由路径或偶环组成。对于偶环，属于$M$和$M'$的边的个数相同；对于路径，由于$\|M'\|>\|M\|$，一定存在一条路径，里面属于$M'$的边的数量多余属于$M$的边，因此这条路径是$M$的增广路，矛盾。

### Hall定理

- $G$中存在饱和$X$的匹配（也叫$X$到$Y$的匹配）的充要条件是$ \forall S\subseteq X,\|N(S)\|\ge\|S\| $，其中$ N(S) $指与$ S $中的顶点邻接的顶点的集合。

    - 必要性：与$S$里的顶点匹配的顶点至少有$\|S\|$个，所以$ N(S)≥\|S\| $

    - 充分性：

        - 反证法。假设不存在饱和$X$的匹配，选择包含$X$最多顶点的一个匹配，此时$X$中存在不属于该匹配的顶点$u$，$u$是不饱和点。
        - 从$u$出发可以得到一个最长的交错路$P$
            - 起点是非饱和点$u$，终点是饱和点（如果是非饱和点，则可以增广，与前面取最大匹配矛盾了）
            - 终点属于$X$。因为$P$里从$X$到$Y$的边都是非匹配边，从$Y$到$X$都是匹配边，最后一个点是饱和点，肯定有对应的匹配边回到$X$。
        - 记$S=X\cap E(P)$，$T=Y\cap E(P)$
            - $S$只比$T$多一个$u$，所以$\|S\|=\|T\|+1$
            - $T\subseteq N(S)$
            - $N(S)$的所有点都是饱和点，否则由于$P$的最后一个点属于$S$，这样可以找到增广路，矛盾
            - 于是$N(S)-T$里的点都是饱和点，由于$P$已经是最长的了，不存在可以继续添加到$P$里的饱和点，所以$N(S)-T$是空集。
            - 其实$P$去掉第一条边，就是一个规整的交错路径，里面的匹配边是$T$和$S-\{u\}$一一映射。
        - 所以$N(S)=T$，与条件$\|N(S)\|≥\|S\|>\|T\|$矛盾。

        总的来说，如果$X$还有非饱和点就能得到$N(S)=T$，刚好比$S$小1，与$N(S)≥S$矛盾。

- 引理：

    - $k$正则偶图存在完美匹配
    - $k(k≥2)$方体存在完美匹配
    - $K_{2n}$的完美匹配个数为$(2n-1)!$
    - 树至多存在一个完美匹配

### 匈牙利算法：求最大匹配

不断寻找增广路，并更新匹配$M$：
```python
任取一个匹配M  # 可以初始化为空集，也可以随便取一条边。
while True:
  find = False
  
  # 尝试从每个非饱和点出发寻找增广路
  for x in X:
    if x饱和:
      continue

    从x开始找一条增广路P
    if P存在:
      find = True
      利用P更新M

  # 不存在增广路了
  if not find:
    break
# 最后就能得到最大匹配M
```

```python
# code
```

这个算法可以改进，因为外层循环是不必要的，它只可能循环一次

*  从x开始找增广路，增广路只会增加一个匹配而已，而且这个新增的匹配是x的匹配
*  如果按顺序遍历x，一开始匹配0，然后匹配1，以此类推
    - 由于饱和点都在前面，所以处理x的时候，找增广路只可能往回找（0~x-1），通过增广路调整匹配的时候，也只可能调整之前的匹配，以及添加当前点x的匹配。
    - 无论是X还是Y，之前的饱和点调整后还是饱和的，非饱和点还是非饱和点，调整之后只有新增的
    - 某些x可能找不到匹配，因为根据Hall定理，饱和X的匹配不一定存在，从x出发不一定有增广路
*  只会循环一次的原因是，如果一个x这次找不到匹配，下一次也找不到
    - 如果从一个点A出发，没有找到增广路径，那么无论再从别的点出发找到多少增广路径来改变现在的匹配，从A出发都永远找不到增广路径。
    - 反证法，假如第二次能找到，可以推出第一次就应该找到
        - 第一次时的匹配为M，第二次的为M'，且$x$的匹配边属于M而不属于M'，也正是因此，$\|M'\|>\|M\|$
        - 于是$M\Delta M'$里包含一条$M$的增广路，且$x$就在这条增广路上，而且是其中的非饱和点，这意味着从x出发是有一条关于M的增广路的，所以第一次就应该找到这条增广路的。

所以代码可以改成这样：
```python
for x in X:  # 遍历X里的非饱和点
  if x饱和:
    continue

  从x开始找一条增广路P
  if P存在:
    利用P更新M
```

C++实现
```cpp
vector<int> matchY;  // 为了方便，matchY作为全局变量
// findAugPath是寻找增广路的函数，下面会介绍它的实现

int hungary(vector<vector<int>> &W) {
    int n = W.size();
    int m = W[0].size();

    int matchNum = 0;
    matchY = vector<int>(m, -1);  // 初始化匹配
    for(int x=0; x<n; x++) {  // 至多寻找n次增广路
        vector<int> visitedY(m, 0);
        if(findAugPath(W, x, visitedY)) {
          matchNum++;
        }
    }
    return matchNum;
}
```

- 寻找增广路

    - 匹配的表示：

        - 用哈希表表示就可以了，`match[x]=y`表示x和y匹配
        - 图的顶点一般是0~n的整数，所以用数组就可以了，数组初始化为全为-1，表示没有匹配
        - 这里有两种选择：一种是记录match[x]=y，另一种是记录match[y]=x
        - 实际上应该记录后者，因为搜索增广路需要判断一个y是不是饱和点，如果保存后者的话就可以直接根据match[y]是否等于-1判断，等于-1就是非饱和点，大于0就是饱和点。

    - 寻找交错树而不是寻找增广路，并且一边查找一边更新匹配

        DFS搜索交错路的过程构成一颗树，称为交错树。

        交错树也由匹配边和非匹配边交错组成，如果交错树树里存在非饱和叶子节点，那么它可以扩大匹配。

        如果交错树的叶子节点都是饱和点，那么它成为匈牙利树。如果只能找到匈牙利树，说明不存在增广路。

        ![](https://secure2.wostatic.cn/static/iemgtCoJhZEiZGRnhzysMo/image.png)

        DFS需要排除访问过的顶点。这里用`visitedY`记录访问过的`Y`中的顶点，为什么不用记录`X`里访问过的顶点呢？因为每次都是从匹配边回到`X`的，匹配边保证了不会访问访问过的顶点。

```cpp
bool findAugPath(vector<vector<int>> &W, int x, vector<int> &visitedY) {
    int m = W[0].size();

    // 从x出发找一条增广路
    for(int y=0; y<m; y++) {
        if(visitedY[y]) continue;
        if(W[x][y] > 0) {
            visitedY[y] = true;
            if(matchY[y] == -1 \|\| findAugPath(W, matchY[y], visitedY)) {
                // 这里有短路求值，合并了两种情况
                matchY[y] = x;  // 隐式的根据匈牙利树修改匹配
                return true;
            }
        }
    }
    return false;
}
```


每次找增广路延长，需要找$n$次，每次需要一次DFS（BFS也行，复杂度更低），总复杂度$O(n^2m)$。一个显然的改进是类似于Dinic算法那样通过BFS一次找多个增广路，这个算法叫Hopcroft-Karp算法。