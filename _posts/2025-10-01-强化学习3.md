---
title: 【强化学习】深度强化学习、AlphaZero
tags: 机器学习 强化学习 深度学习 笔记
published: true
---

本文介绍深度强化学习算法，即把神经网络引入深度学习。
<!--more-->

为什么强化学习需要神经网络？之前介绍的Model Free方法都是基于网格的方法，用一个网格来表示Q函数。但是这样有很大的局限性，当状态非常多甚至无限的情况下，网格方法完全无法使用，此时用别的方法表示Q函数就非常必要了。神经网络作为通用的函数估计器就是一个非常好的选择，在很多场景下都能很好的近似Q函数，原因在于很多状态空间具有特殊的结构：例如图像作为状态就非常适合用CV模型进行处理，神经网络擅长处理这种流形结构。可以说传统基于网格的方法可以说纯靠“记忆”，而基于神经网络的方法可以在一定程度上“泛化”，这种泛化能力意味着训练过程中不需要把所有状态全部探索一遍，只需要探索一个子集就能在整个状态空间上达到较好的拟合效果。


<div align=center>
<img src="../../../assets/images/posts/2025-10-01/drl.svg" width="40%" />
</div>

如上图所示，把神经网络引入强化学习有两个流派，**Value-based（值函数近似）**流派和**Policy-based（策略梯度）**流派：

1. ​值函数近似​​流派的思想是，用一个神经网络来直接学习状态或状态-动作对的价值（Q函数或V函数）。学成之后，智能体只需选择价值最高的动作即可（即 argmax操作）。

2. 策略梯度​​流派则更为直接，它让神经网络绕过价值评估，直接学习动作的概率分布（即策略）。

当今的主流方法（如PPO、TD3、SAC等）使用的是二者的结合体Actor-Critic，都会用到。但本文只介绍Value-based方法和Polic-based方法，以及它们的一个著名应用AlphaZero，Actor-Critic留给下一篇文章。


## Value-Based方法

Value-based方法延续了之前Model Free的方法，都是通过求解最优Q函数得到最优策略，只是Value-based方法**使用神经网络近似Q函数或V函数**。典型的代表是围棋AI，使用神经网络预测每种下法的胜率（就是Q函数），并结合树搜索选择胜率最高的下法（就行取argmax得到策略）。

### DQN

[DQN(2013)](https://arxiv.org/abs/1312.5602)是值函数近似流派的代表性算法，使用CNN近似Q函数来玩游戏。输入是图像和不同的action，输出是回报。


#### DQN的算法思路

DQN的核心想法很简单：用神经网络求解Bellman最优方程。已知Bellman最优方程为：

$$
Q(s,a)=E_{s'\sim p(\cdot|s,a)}[r+\gamma\ \max\limits_{a'}Q(s',a')]
$$

要用神经网络近似 $Q$，使得对任意的 $s,a,r,s'$ 上述方程都能近似成立，可以使用MSE损失函数：

$$
\mathcal{L} = \frac1B\sum_{i=1}^B \left[ Q_{\theta}(s_i, a_i) - \underbrace{\left[r_i + \gamma \max_{a'} Q_{\theta}(s'_i, a')\right]}_{\text{“TD Target”}} \right]^2 

$$

这相当于训练一个回归模型，它的训练目标是和Q-Learning一样的TD Target。特别地，当 $s'$ 是结束状态时（在 $s$ 采取行为 $a$ 后如果游戏结束，返回的下一个状态 $s'$ 没有实际意义），$Q(s,a)=r$ 是准确的值。综合来看，训练目标为：

$$
\text{target}=
\begin{cases}
r & s'是结束状态\\
r+\gamma\max\limits_a Q_{\theta}(s',a) & s'不是结束状态
\end{cases}
 
$$

于是目标函数变为：

$$
J(\theta)=\frac1B\sum\limits_{i=1}^B
[Q_{\theta}(s_i,a_i) - \text{target}_i]^2
$$

这是一个非常简单的MSE loss，整体思想也很简单，不过实际使用的时候会遇到两个问题：

第一个问题是**训练数据从哪来？**如果使用现有策略**连续采样**产生的 $B$ 个数据作为一个batch对神经网络训练会导致神经网络严重的过拟合，因为样本之间不独立，相关性太高，类似于流式训练，模型无法拟合整个状态空间上的分布。为了解决这个问题，DQN提出**_经验回放_**策略，使用一个比较大的队列（名字叫**_replay buffer_**）保存走过的 $<s,a,r,s'>$，每个这样的四元组称为一个**_transition_**。如果replay buffer够大，就可以认为从中随机采样的样本独立同分布，也就避免了前面的问题。计算loss的时候每次从中采样一个batch的样本来近似期望$E_{\pi}$（replay buffer需要设大一些）。值得注意的是引入replay buffer的前提是这个算法是Off Policy的，而DQN是直接求解Bellman最优方程，是Off Policy的。

第二个问题是**训练目标 $r+\gamma \max\limits_a Q_{\theta}(s',a)$ 会随着模型参数不断变化，导致训练及其不稳定**。DQN的解决办法是将网络拷贝一份并保持参数不变来构建目标，这个拷贝的网络称为**_目标网络_**，记为 $Q_{\theta'}$，此时训练目标为：

$$

\text{target}=
\begin{cases}
r & s'是结束状态\\
r+\gamma\max\limits_a Q_{\textcolor{red}{\theta'}}(s',a) & s'不是结束状态
\end{cases}

$$

其中 $\theta'$ 是目标网络的被固定住的参数，每迭代一定的次数，就令 $\theta'\leftarrow \theta$ 更新目标网络。熟悉视觉自监督的读者可能会发现这个和视觉自监督的方法很类似，也是用不参与训练的模型给自己当teacher，类似于[meanTeacher](https://arxiv.org/abs/1703.01780)那种做法。但是这里为什么不用移动平均更新 $\theta'$ 呢？单纯是因为DQN提出太早，后来的方法都改用移动平均了。

#### 具体算法

1. 初始化一个最大长度为 $K$ 的队列 $q$ 作为replay buffer
1. 初始化 $Q_{\theta}$，拷贝 $Q_{\theta}$ 得到 $Q_{\theta'}$
1. 基于 $Q_{\theta}$ 的 $\epsilon$-greedy策略进行探索，将 $<s,a,r,s'>$ 添加到对列中，直到对列装满
1. 迭代 $N$ 次：
    * 从replay buffer中均匀采样 $B$ 个样本，对每个样本计算 $\text{target}$
    * 计算损失函数，使用优化算法更新一次参数
    * 基于 $Q_{\theta}$ 探索一步（$\epsilon$-greedy），将 $<s,a,r,s'>$ 添加到对列中，并把队头的数据丢掉
    * 每迭代 $C$ 次，$\theta'\leftarrow \theta$

#### DQN的优缺点

DQN的优点是off-policy的，不需要用自己的策略收集数据，只要有数据就能训练。replay buffer中的大部分数据来源于很多步迭代之前的策略，和当前策略不同，但是依旧可以用来训练模型，这是off-policy的性质保证的。除此之外，DQN提出的2个方法：目标网络以及replay buffer非常有用，后面的几乎所有算法都有使用。DQN的缺点是继承了Q-Learning的高估问题，且只能解决离散动作空间的问题，而且很玄学，深度学习本身就比较玄学，深度强化学习更是玄学中的玄学，需要很仔细的调参才能work。

### DQN的一些改进

* [Double DQN(2015)](https://arxiv.org/abs/1509.06461)把Double Q-Learning的算法迁移过来解决高估问题。因为DQN本身就有一个额外的目标网络，刚好很契合Double Q-Learning的需求，所以不需要额外再训练一个神经网络。Double DQN就是把DQN的TD Target改成了 $r + \gamma Q_{\theta'}(s', \text{argmax} Q(s,a))$。
* [Prioritized replay(2015)](https://arxiv.org/abs/1511.05952)改进了从replay buffer采样batch的方式，原本是均匀采样，现在是按优先级采样，基于优先级更高、更重要的数据训练收敛更快且效果更好。那么优先级从哪来的？论文中把TD Error加上一个常量作为优先级，还会加上一个常量进行平滑。除此之外，为了保证每个数据都至少被采样一次，新数据会直接被加入到batch中。除此之外，还有通过重要性采样调整每个样本的loss权重以修正非均匀采样带来的偏差。
* [Dueling DQN(2015)](https://arxiv.org/abs/1511.06581)修改了Q函数神经网络的设计，这里涉及**_优势函数_** $A(s, a)=Q(s,a)-V(s)$ 的概念，表示某个动作相较于平均而言能带来多大的优势，可以用来建模一个action对长期回报的影响。基于这个公式，Dueling DQN把 $Q_{\theta}$ 建模为 $V_{\theta}(s)+[A_{\phi}(s,a)-\frac1{\|\mathcal A\|}\sum_a A_{\phi}(s,a)]$，显示地分开建模“状态好坏”和“动作好坏”。考虑到 $V_{\theta}$ 和 $A_{\phi}$ 都有状态 $s$ 的输入，可以让它们两个共享编码 $s$ 的网络。这里优势函数会减去Batch内不同action价值的均值应该是有偏的，但是也能work。
* [NoisyNet(2017)](https://arxiv.org/pdf/1706.10295)把神经网络的参数建模为随机的，例如假设参数服从多元高斯分布 $\mathcal N(w, \sigma)$，既要学均值，也要学方差。参数是随机，那么神经网络近似的Q函数就是随机的，对应的策略也是随机的，因而可以加强探索、改进模型效果。需要注意的点是不能在每次forward都重新采样模型参数，在模型的两次更新之间不应该重新采样模型参数，使得采样一条轨迹的策略是一致的。
* [Rainbow DQN(2017)](https://arxiv.org/abs/1710.02298)缝合了DQN的各种改进，包括上面的4个，还有TD(1)改为TD(n)等等。如果想要使用值函数流派的算法解决问题可以使用Rainbow DQN。




## Policy-Based方法

策略梯度方法是一个和值函数近似很不同的流派，直接用神经网络 $\pi_{\theta}$ 来近似策略，思路更直接、更好理解。策略梯度法的核心是**策略梯度定理**，它是Richard Sutton在1999年的REINFORCE算法论文中提出，下面进行介绍。

### 策略梯度定理

如果想要优化策略，我们需要有一个目标函数，那么策略梯度的目标函数是什么？在强化学习中，这个问题的答案并不唯一，如果粗略的划分可以分为两类，这两类都挺常见：

1. 基于状态的目标函数

    $$
    \mathcal L = E_{s\sim d}[V(s)]
    $$

    其中 $d(s)$ 是 $s$ 的某种分布，不同的分布代表不同的目标。如果起始状态是唯一的 $s_0$，那么我们可以只最大化 $V(s_0)$，例如玩Atari游戏的场景；如果初始状态不唯一，那么目标是最大化 $E_{s\sim \mu} [V(s)]$，其中 $\mu(s)$ 是初始状态分布；还有更复杂的情况，即 $d$ 是依赖于策略的，例如取整个过程的平稳分布，此时要通过梯度方法优化这个目标函数会很困难，因为梯度不仅和 $V(s)$ 有关，还和复杂的分布 $d$ 有关，此时一般会忽略对 $d$ 的梯度，用一个有偏差的梯度去更新模型。不过我个人感觉这种情况没有意义，因为rollout总是从初始策略开始的。

2. 基于轨迹的目标函数

    除了前面介绍的策略梯度，还有一个版本的策略梯度很常见，它是最大化轨迹上的价值函数，例如这个经典的强化学习[博客](https://danieltakeshi.github.io/2017/04/02/notes-on-the-generalized-advantage-estimation-paper/)还有李宏毅老师的课程都是基于这一类价值函数去讲的。用给定的策略 $\pi_{\theta}$ 在环境中探索能够得到轨迹 $\tau$，这个轨迹是一个随机变量因为它取决于环境的状态转移以及策略这两个随机因素，因此不妨把轨迹服从的分布简单记为 $\tau\sim \pi_{\theta}$（一个常见的记法）。然后我们基于 $\tau$ 定义目标函数去最大化轨迹上的价值：

    $$
    \mathcal L = E_{\tau \sim \pi_{\theta}}[\frac1T\sum_{t=0}^{T} Q^{\pi_{\theta}}(s_t, a_t)]
    $$

    其中 $s_t,a_t$ 是轨迹上的状态和行为。这个定理本质上和第一种状态类目标函数是一样的，但它看起来更简单、没有分各种情况，这是因为轨迹 $\tau$ 的分布既和初始状态分布 $\mu$ 有关，也和当前策略、状态转移有关，相当于把复杂的东西都扔进轨迹 $\tau$ 里面了。

无论是哪种目标函数，我们都需要求它的梯度来训练模型 $\pi_{\theta}$。这两类目标函数的梯度不太相同。状态类目标函数虽然有多种情况，但是它们的梯度都有类似的形式，[策略梯度定理(1999)](https://proceedings.neurips.cc/paper_files/paper/1999/file/464d828b85b0bed98e80ade0a5c43b0f-Paper.pdf)给出了这些目标函数的梯度：

<div class="theorem">
$$
\begin{aligned}
\nabla \mathcal L
& \approx
\frac1{1-\gamma}
E_{s \sim d^{\pi_{\theta}}(\cdot)} \left[
    E_{a\sim \pi_{\theta}(\cdot|s)}[Q^{\pi_{\theta}}(s,a)\nabla\ln\pi_{\theta}(a|s)]
\right]
\\
& \propto E_{s,a\sim \pi_{\theta}}[Q^{\pi_{\theta}}(s,a)\nabla\ln\pi_{\theta}(a|s)]

\end{aligned}
$$

其中 $d^{\pi_{\theta}}$ 是一个和策略有关的状态分布，表示按策略 $\pi_{\theta}$ 从初始状态开始游走的状态分布。$s,a\sim\pi_{\theta}$ 表示 $s,a$ 都是用策略 $\pi_{\theta}$ 随机游走采样得到的（这个分布不好说叫什么名字）。
</div>

这个公式<span style="color: red; font-weight: bold;">在一些情况下是等于，在一些情况下是约等于（大多数情况）</span>，具体可以参考[《强化学习的数学原理》](https://github.com/MathFoundationRL/Book-Mathematical-Foundation-of-Reinforcement-Learning/blob/main/3%20-%20Chapter%209%20Policy%20Gradient%20Methods.pdf)。但无论如何，我们都可以用策略梯度定理给出的梯度值去优化模型，只是可能需要调调学习率。

直观来看，$Q^{\pi_{\theta}}(s,a)\nabla \ln\pi_{\theta}(a\|s)$ 就是由Q函数加权的交叉熵损失，标签是智能体采取的action，在 $Q$ 比较大就鼓励模型分类出这个动作，否则打压这个动作。
{:.info}

轨迹类目标函数的梯度是：

$$
\nabla\mathcal L = E_{\tau \sim \pi_{\theta}}[
    \frac1T\sum_{t=0}^{T} Q^{\pi_{\theta}}(s_t, a_t) \nabla\ln\pi_{\theta}(a_t|s_t)
]
$$

这个推导很简单，所以先介绍轨迹类目标函数的策略梯度定理怎么推导，再给出状态类策略梯度定理的证明。

策略梯度定理的意义在于，它右边的期望项可以通过采样来近似。我们不需要求关于 $d$ 的梯度，只需要用现有策略探索得到轨迹 $<s_0,a_0,r_1,s_1,\cdots>$，并用轨迹中的 $s$ 和 $a$ 计算 $Q^{\pi_{\theta}}(s,a)\nabla \ln\pi_{\theta}(a\|s)$ 并取平均即可。

### SFGE梯度估计算法

SFGE的全称是Score Function Gradient Estimate，用来求 $\nabla_{\theta} E_{p_{\theta}(x)}[f(x)]$，在两类策略梯度的证明中都有用它的思路。它的思路很简单：

$$
\begin{aligned}
\nabla_{\theta} E_{p_{\theta}(x)}[f(x)]
&=\nabla_{\theta} \int f(x)p_{\theta}(x)dx\\
&=\int f(x)  \textcolor{red}{\nabla_{\theta} p_{\theta}(x)}  dx\\
&=\int f(x)  \textcolor{red}{p_{\theta}(x)\nabla_{\theta}\ln p_{\theta}(x)} dx\\
&=E_{p_{\theta}(x)}[f(x)\nabla_{\theta}\ln p_{\theta}(x)]
\end{aligned} 
$$

公式里面红色的部分叫**_Log Derivative Trick_**，这个trick的作用是把 $p_{\theta}(x)$ 变出来，使公式能写成期望的形式。现在梯度移到了期望里面，可以用蒙特卡洛法估计了：

$$
\nabla_{\theta} E_{p_{\theta}(x)}[f(x)]
\approx
\frac1m\sum\limits_{i=1}^m f(x_i)\nabla_{\theta} \ln p_{\theta}(x_i) 
$$

$\nabla_{\theta}\ln p_{\theta}(x)$ 称为**_score Function_**，是一个梯度场。这个函数比较重要，扩散模型里面也有。score function的一个性质是期望为0：

$$
E_{p_{\theta}(x)}[\nabla_{\theta}\ln p_{\theta}(x)]
=\nabla_{\theta} E_{p_{\theta}(x)}[1]
=\nabla_{\theta} 1
=0
$$

利用均值为0的特点可以通过一些手段降低梯度估计的方差，从而降低估计难度：

$$
\nabla_{\theta} E_{p_{\theta}(x)}[f(x)-b]
=E_{p_{\theta}(x)}[
f(x)\nabla_{\theta}\ln p_{\theta}(x)-b\nabla_{\theta}\ln p_{\theta}(x)
]
=\nabla_{\theta} E_{p_{\theta}(x)}[f(x)]
$$

其中 $b$ 是一个常数，一般叫它**_baseline_**。上式说明了减去baseline不改变估计的期望，但是可以降低估计的方差，因为可以推出方差是一个关于 $b$ 的函数，当 $b=E_{p_{\theta}(x)}[f(x)]$ 时方差最小，且一定比 $b=0$ 时更小，这里就不给出证明了。


### 轨迹类策略梯度

理解了SFGE后，轨迹类策略梯度可以直接用SFGE方法求，只要求出 $\tau$ 服从的概率密度函数 $p(\tau)$ 的score function即可。记状态的初始分布的概率密度函数是 $\mu(s)$，有了初始分布我们可以写出轨迹 $\tau=<s_0,a_0,r_1,s_1,a_1,\cdots>$ 的概率密度函数为：

$$
p(\tau) = \mu(s_0)\prod_{t=0}^{T} p(s_{t+1}|s_t,a_t)\pi_{\theta}(a_t|s_t)
$$

对它的对数求导得到score function：


$$
\begin{aligned}
\nabla\ln p(\tau) &= \nabla\ln\mu(s_0) + \nabla\sum_{t=0}^{T} \ln p(s_{t+1}|s_t,a_t) + \nabla\sum_{t=1}^T \ln\pi_{\theta}(a_t|s_t)
\\
&= \nabla\sum_{t=1}^T \ln\pi_{\theta}(a_t|s_t)
\end{aligned}
$$

把这个score function带进SFGE公式就推出了轨迹类策略梯度。

### REINFORCE算法

REINFORCE算法使用蒙特卡洛法采样轨迹来估计策略梯度，每次迭代采样一条轨迹、计算loss、更新一次模型，当然采样多条轨迹组成batch计算loss也是可以的。对于轨迹 $<s_0,a_0,r_1,\cdots,r_{T-1},s_T>$，用这条轨迹的回报 $G_t=\sum\limits_{s=t+1}^{T-1}{\gamma}^{s-t-1}r_{s}$ 近似 $Q(s_t,a_t)$，于是策略梯度为近似为：

$$
\frac1T\sum\limits_{t=0}^{T-1}
G_t\nabla \ln\pi_{\theta}(a_t|s_t)
=
\nabla\frac1T\sum\limits_{t=0}^{T-1}
G_t\ln\pi_{\theta}(a_t|s_t)
$$

直观来看，这就是以$G_t$为权重的交叉熵损失函数，$G_t$ 越大越鼓励该行为。

前面SFGE方法中说明了通过减去baseline可以减小方差，把这个思路用在REINFORCE算法上，让 $G_t$ 减去一个常数 $B$ 使得交叉熵的系数有正有负会更好，**只要这个常数 $B$ 跟action无关就行**。引入baseline后公式变为：

$$
\nabla \frac1T\sum\limits_{t=0}^{T-1}
[(G_t-B)\ln\pi_{\theta}(a_t|s_t)]
$$

$B$ 一般使用 $G_t$ 在Batch内均值。减去Baseline的就是鼓励超过平均奖励的行为，不鼓励低于平均奖励的行为。

REINFORCE算法类似于值函数方法中的蒙特卡洛强化学习算法，每个采样一个轨迹才更新一次，做不到每走一步都更新模型，训练比较慢。后续方法都改为了每步都更新，这时就不能用轨迹类策略梯度，需要使用状态类的策略梯度。


## AlphaZero

[AlphaGo](https://www.nature.com/articles/nature16961)以及之后的[AlphaZero](https://arxiv.org/abs/1712.01815)使用蒙特卡洛树搜索（MCTS）+深度强化学习（DRL）实现超越人类的围棋水平。这种结合蒙特卡洛估计和深度学习的思路贯穿了整个AlphaZero算法的设计。并且AlphaGo和AlphaZero的很多设计都考虑了围棋的特点，例如Model-Based、棋盘状态的平移不变性、在CNN的输入中引入围棋的规则等等，非常值得学习。

### MCTS

蒙特卡洛树搜索的思路很简单：通过大量模拟对弈（Rollout）来统计每种下法的胜率，每次选择胜率最高的下法下棋。这有点类似于Alpha-Beta剪枝的搜索算法，只是把节点之间的min-max的关系替换为了期望，统计不同下法的回报（reward函数是赢棋返回1，和棋0，输棋-1）。MCTS的做法相当于rollout非常多次，直接基于rollout的结果用蒙特卡洛法估计值函数：

<div align=center>
<img src="../../../assets/images/posts/2025-10-04/MCTS.png" width="40%" />
</div>

这种rollout是“假想的”，是一种model-based的搜索方法，已知状态会如何迁移才能这样做，在围棋中规则是已知的，棋盘状态也是已知的，所以可以这么做。但是单纯的MCTS在围棋上几乎不可行，因为围棋的状态空间太多了，纯基于搜索的方法几乎不可行。

**一种MCTS的改进方法是把MCTS和一个策略结合**。在每次假想的rollout中，让对方和自己都基于这个策略去下棋，因为这个策略本身就有较强的下棋能力，在下棋的时候就能直接排除很多不好的下法，减小搜索空间，把更多的模拟次数集中在更好地下法上。这样本质上是在估计这个策略的值函数，在估计好后通过argmax选择胜率最高的下法其实是在进行一次策略改进。但是因为整个过程没有反复的改进策略，所以最终效果完全取决于策略本身的好坏，没有不断改进的能力。通常这个策略是使用监督学习或强化学习的方法训练的。

**AlphaGo不仅把策略和MCTS结合，还把V函数用在截断MCTS上，二者都用神经网络近似，并结合REINFORCE和DQN的思路不断训练模型改进策略和值函数估计**。结合价值函数的方法是在搜索的时候，不去把一局下完，而是只下一部分（下到指定步数），剩下的改用 $V(s)$ 估计赢的概率，这样结合了基于搜索的rollout和神经网络的预测，有点类似于时间差分的TD(n)，能够进一步减小搜索的计算量。AlphaGo使用这样的策略下棋收集数据，使用REINFORCE算法训练策略网络，使用DQN训练价值网络，让策略、值函数不断改进，最终达到超越人类的水平。所以AlphaGo算法简单来说就是MCTS+REINFORCE+DQN，细节上则使用了很多方法来加速以及保证它能work。

AlphaZero中实际使用的MCTS是一个改进版本，叫APV-MCTS。在MCTS中，树的每个节点是状态 $s$，每个边则代表在该状态的一个动作，可以表示为 $(s,a)$。APV-MCTS给每个边维护一些属性，包括：
* rollout的次数 $N_r(s,a)$（子树中叶子节点的个数）
* 所有rollout的reward的和 $W_r(s,a)$
* 动作价值函数$ Q(s,a）$
* 先验概率 $p(s,a)$。先验概率是策略函数预测的概率，会给最后的softmax设定比较高的温度系数。

整个搜索分为两个阶段：**前 $L$ 步是第一阶段**，这一阶段忽略策略，每一步在搜索选择行为的时候，会选择 $\text{argmax}_a\{ Q(s,a)+ u(s,a)\}$，其中 $u(s,a)$ 是：

$$
u(s,a) = c_{\text{puct}}p(s,a)\frac{\sqrt{\sum_b N_r(s,b)}}{1+N_r(s,a)}
$$

$u$ 函数用来保证搜索的初期能够进行更多的探索，更偏向先验概率高的行为以及访问次数少的行为。$c_{\text{puct}}$ 是一个常数用来控制探索的程度。**第 $L$ 步到分出输赢是第二阶段**，这一步纯粹基于策略进行rollout。整体来看，这样的两阶段搜索策略是希望搜索的前期进行更多探索，后期棋盘的局势相对确定已定再用神经网络预测，还是相当巧妙的。

注意上面还没有涉及值函数 $V(s)$ 是怎么用的。在rollout的时候，AlphaGo一方面完全基于蒙特卡洛估计维护 $N_r$ 和 $W_r$，同时也会基于值函数去维护 $N_v$ 和 $W_v$。基于蒙特卡洛的估计需要rollout到叶子节点才能统计，而基于值函数的估计只需要rollout到第一阶段结束即可。最后Q函数的估计是 $\frac{W_r(s,a)}{N_r(s,a)}$ 与 $\frac{W_v(s,a)}{N_v(s,a)}$ 的加权求和。训练中的rollout过程有点像神经网络的前向传播，而根据rollout的结果更新每个边上的状态有点类似于反向传播。在推理的时候，下棋的最开始会搜索多步，当对手采取了某个行为后，只需要把对应的子树拿出来继续搜索，这样可以复用之前的大部分搜索结果。

### DRL

策略网络和Value Network都使用了ResNet，其主要考量是围棋规则在是平移不变的，与CNN相契合。模型的输入是 $19\times 19\times C$ 的数组，其中 $19\times 19$ 是棋盘格的大小，而 $C$ 是channel个数。输入策略网络的有48个channel，包含了不同的特征，例如最近几步白棋的位置、黑棋的位置、空白的位置等等。输入Value Network的是49个channel，比策略网络的输入多了一个channel表明当前轮到黑棋还是白棋走。策略网络是一个分类网络，类别数量 $19\times 19$ 。而Value Network是一个回归网络，输出是一个连续值。

两个网络的训练方法相对简单，和之前介绍的强化学习算法类似，只是数据来源不纯粹来源策略网络，而是结合了MCTS的策略收集的。

* 策略网络训练：策略网络使用REINFORCE算法训练，用多个GPU同时下棋收集 $B$ 个Batch进行训练，并使用 $V(s)$ 作为baseline来减小方差。应该说这是一个REINFORCE和Actor Critic的结合算法。因为推理的时候是使用Value Network进行蒙特卡洛树搜索，所以Policy Network的作用是用来训练Value Network，而不是用来推理。这也体现出Model-Based RL的一个特点，能直接搜索总是比模型预测更好。

* Value Network训练：训练数据也是rollout时的数据，会在围棋的不同步数均匀的采样状态 $s$ 进行训练，模型直接预测最终reward，相当于 $\gamma=1$ 的回报。


## 总结

本文梳理了深度强化学习的两类算法，Value-based算法与Policy-based算法。Value-based的算法着重介绍了DQN以及后续的一些改进思路，在策略梯度部分则着重厘清了不同的策略梯度形式以及轨迹类策略梯度的证明，并给出了REINFORCE算法以及如何进行方差缩减。最后为了帮助理解这两种算法在实际问题中是如何使用的，阐述了DQN和REINFORCE算法的一个著名应用AlphaZero。
